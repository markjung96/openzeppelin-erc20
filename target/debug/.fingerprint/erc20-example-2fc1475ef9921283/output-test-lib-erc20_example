{"$message_type":"diagnostic","message":"cannot find attribute `public` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":758,"byte_end":764,"line_start":39,"line_end":39,"column_start":3,"column_end":9,"is_primary":true,"text":[{"text":"#[public]","highlight_start":3,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `public` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:39:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[public]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `inherit` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":768,"byte_end":775,"line_start":40,"line_end":40,"column_start":3,"column_end":10,"is_primary":true,"text":[{"text":"#[inherit(Erc20, Erc20Metadata, Capped, Pausable)]","highlight_start":3,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `inherit` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:40:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[inherit(Erc20, Erc20Metadata, Capped, Pausable)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `storage` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":575,"byte_end":582,"line_start":27,"line_end":27,"column_start":3,"column_end":10,"is_primary":true,"text":[{"text":"#[storage]","highlight_start":3,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `storage` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:27:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[storage]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `borrow` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":612,"byte_end":618,"line_start":29,"line_end":29,"column_start":7,"column_end":13,"is_primary":true,"text":[{"text":"    #[borrow]","highlight_start":7,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `borrow` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:29:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[borrow]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `borrow` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":644,"byte_end":650,"line_start":31,"line_end":31,"column_start":7,"column_end":13,"is_primary":true,"text":[{"text":"    #[borrow]","highlight_start":7,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `borrow` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:31:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[borrow]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `borrow` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":687,"byte_end":693,"line_start":33,"line_end":33,"column_start":7,"column_end":13,"is_primary":true,"text":[{"text":"    #[borrow]","highlight_start":7,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `borrow` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:33:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[borrow]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find attribute `borrow` in this scope","code":null,"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":721,"byte_end":727,"line_start":35,"line_end":35,"column_start":7,"column_end":13,"is_primary":true,"text":[{"text":"    #[borrow]","highlight_start":7,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: cannot find attribute `borrow` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:35:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[borrow]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `alloc::vec::Vec`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":76,"byte_end":91,"line_start":4,"line_end":4,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":72,"byte_end":93,"line_start":4,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use alloc::vec::Vec;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `alloc::vec::Vec`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:4:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse alloc::vec::Vec;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `openzeppelin_stylus::token::erc20::extensions::capped::Error: MethodError` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":437,"byte_end":450,"line_start":19,"line_end":19,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(SolidityError, Debug)]","highlight_start":10,"highlight_end":23}],"label":"the trait `SolError` is not implemented for `openzeppelin_stylus::token::erc20::extensions::capped::Error`, which is required by `openzeppelin_stylus::token::erc20::extensions::capped::Error: MethodError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":437,"byte_end":450,"line_start":19,"line_end":19,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(SolidityError, Debug)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(SolidityError)]","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stylus-proc-0.5.2/src/lib.rs","byte_start":12089,"byte_end":12152,"line_start":292,"line_end":292,"column_start":1,"column_end":64,"is_primary":false,"text":[{"text":"pub fn derive_solidity_error(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `SolError`:\n  stylus_sdk::alloy_sol_types::Panic\n  stylus_sdk::alloy_sol_types::Revert","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `openzeppelin_stylus::token::erc20::extensions::capped::Error` to implement `MethodError`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `openzeppelin_stylus::token::erc20::extensions::capped::Error: MethodError` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:19:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(SolidityError, Debug)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `SolError` is not implemented for `openzeppelin_stylus::token::erc20::extensions::capped::Error`, which is required by `openzeppelin_stylus::token::erc20::extensions::capped::Error: MethodError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `SolError`:\u001b[0m\n\u001b[0m             stylus_sdk::alloy_sol_types::Panic\u001b[0m\n\u001b[0m             stylus_sdk::alloy_sol_types::Revert\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `openzeppelin_stylus::token::erc20::extensions::capped::Error` to implement `MethodError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `SolidityError` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `openzeppelin_stylus::token::erc20::Error: MethodError` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":437,"byte_end":450,"line_start":19,"line_end":19,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(SolidityError, Debug)]","highlight_start":10,"highlight_end":23}],"label":"the trait `SolError` is not implemented for `openzeppelin_stylus::token::erc20::Error`, which is required by `openzeppelin_stylus::token::erc20::Error: MethodError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":437,"byte_end":450,"line_start":19,"line_end":19,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(SolidityError, Debug)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(SolidityError)]","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stylus-proc-0.5.2/src/lib.rs","byte_start":12089,"byte_end":12152,"line_start":292,"line_end":292,"column_start":1,"column_end":64,"is_primary":false,"text":[{"text":"pub fn derive_solidity_error(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `SolError`:\n  stylus_sdk::alloy_sol_types::Panic\n  stylus_sdk::alloy_sol_types::Revert","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `openzeppelin_stylus::token::erc20::Error` to implement `MethodError`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `openzeppelin_stylus::token::erc20::Error: MethodError` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:19:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(SolidityError, Debug)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `SolError` is not implemented for `openzeppelin_stylus::token::erc20::Error`, which is required by `openzeppelin_stylus::token::erc20::Error: MethodError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `SolError`:\u001b[0m\n\u001b[0m             stylus_sdk::alloy_sol_types::Panic\u001b[0m\n\u001b[0m             stylus_sdk::alloy_sol_types::Revert\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `openzeppelin_stylus::token::erc20::Error` to implement `MethodError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `SolidityError` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `openzeppelin_stylus::utils::pausable::Error: MethodError` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":437,"byte_end":450,"line_start":19,"line_end":19,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(SolidityError, Debug)]","highlight_start":10,"highlight_end":23}],"label":"the trait `SolError` is not implemented for `openzeppelin_stylus::utils::pausable::Error`, which is required by `openzeppelin_stylus::utils::pausable::Error: MethodError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":437,"byte_end":450,"line_start":19,"line_end":19,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(SolidityError, Debug)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(SolidityError)]","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stylus-proc-0.5.2/src/lib.rs","byte_start":12089,"byte_end":12152,"line_start":292,"line_end":292,"column_start":1,"column_end":64,"is_primary":false,"text":[{"text":"pub fn derive_solidity_error(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the following other types implement trait `SolError`:\n  stylus_sdk::alloy_sol_types::Panic\n  stylus_sdk::alloy_sol_types::Revert","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `openzeppelin_stylus::utils::pausable::Error` to implement `MethodError`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `openzeppelin_stylus::utils::pausable::Error: MethodError` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:19:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(SolidityError, Debug)]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `SolError` is not implemented for `openzeppelin_stylus::utils::pausable::Error`, which is required by `openzeppelin_stylus::utils::pausable::Error: MethodError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `SolError`:\u001b[0m\n\u001b[0m             stylus_sdk::alloy_sol_types::Panic\u001b[0m\n\u001b[0m             stylus_sdk::alloy_sol_types::Revert\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `openzeppelin_stylus::utils::pausable::Error` to implement `MethodError`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `SolidityError` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Erc20Example: stylus_sdk::prelude::StorageType` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":591,"byte_end":603,"line_start":28,"line_end":28,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"struct Erc20Example {","highlight_start":8,"highlight_end":20}],"label":"the trait `stylus_sdk::prelude::StorageType` is not implemented for `Erc20Example`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `stylus_sdk::prelude::StorageType`:\n  PhantomData<T>\n  StorageAddress\n  StorageArray<S, N>\n  StorageBlockHash\n  StorageBlockNumber\n  StorageBool\n  StorageBytes\n  StorageFixedBytes<N>\nand 5 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Erc20Example: stylus_sdk::prelude::StorageType` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:28:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mstruct Erc20Example {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `stylus_sdk::prelude::StorageType` is not implemented for `Erc20Example`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `stylus_sdk::prelude::StorageType`:\u001b[0m\n\u001b[0m             PhantomData<T>\u001b[0m\n\u001b[0m             StorageAddress\u001b[0m\n\u001b[0m             StorageArray<S, N>\u001b[0m\n\u001b[0m             StorageBlockHash\u001b[0m\n\u001b[0m             StorageBlockNumber\u001b[0m\n\u001b[0m             StorageBool\u001b[0m\n\u001b[0m             StorageBytes\u001b[0m\n\u001b[0m             StorageFixedBytes<N>\u001b[0m\n\u001b[0m           and 5 others\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Erc20Example: Router<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":559,"byte_end":572,"line_start":26,"line_end":26,"column_start":1,"column_end":14,"is_primary":true,"text":[{"text":"#[entrypoint]","highlight_start":1,"highlight_end":14}],"label":"the trait `Router<_>` is not implemented for `Erc20Example`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":559,"byte_end":572,"line_start":26,"line_end":26,"column_start":1,"column_end":14,"is_primary":false,"text":[{"text":"#[entrypoint]","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[entrypoint]","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/stylus-proc-0.5.2/src/lib.rs","byte_start":15089,"byte_end":15160,"line_start":363,"line_end":363,"column_start":1,"column_end":72,"is_primary":false,"text":[{"text":"pub fn entrypoint(attr: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":72}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `Erc20Example: Router<_>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:26:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[entrypoint]\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Router<_>` is not implemented for `Erc20Example`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the attribute macro `entrypoint` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":1420,"byte_end":1427,"line_start":61,"line_end":61,"column_start":30,"column_end":37,"is_primary":true,"text":[{"text":"        self.erc20.burn_from(account, value).map_err(|e| e.into())","highlight_start":30,"highlight_end":37}],"label":"expected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1410,"byte_end":1419,"line_start":61,"line_end":61,"column_start":20,"column_end":29,"is_primary":false,"text":[{"text":"        self.erc20.burn_from(account, value).map_err(|e| e.into())","highlight_start":20,"highlight_end":29}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":2236,"byte_end":2320,"line_start":68,"line_end":68,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs","byte_start":1062,"byte_end":2776,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":1},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":1},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":1},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":1},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":1},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":1},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":1},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":1},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":1},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":1},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":1},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Examples","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":1},{"text":"    /// let expected = address!(\"d8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":1},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":1},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":549,"byte_end":578,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":2288,"byte_end":2372,"line_start":69,"line_end":69,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs","byte_start":1090,"byte_end":2806,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":1},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":1},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":1},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":1},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":1},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":1},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":1},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":1},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":1},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":1},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":1},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Examples","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":1},{"text":"    /// let expected = address!(\"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":1},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":1},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":554,"byte_end":583,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/extensions/burnable.rs","byte_start":1575,"byte_end":1584,"line_start":52,"line_end":52,"column_start":8,"column_end":17,"is_primary":true,"text":[{"text":"    fn burn_from(","highlight_start":8,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:61:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.erc20.burn_from(account, value).map_err(|e| e.into())\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/extensions/burnable.rs:52:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn burn_from(\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `wrap_fixed_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2314,"byte_end":2321,"line_start":89,"line_end":89,"column_start":26,"column_end":33,"is_primary":true,"text":[{"text":"        self.erc20._mint(account, value)?;","highlight_start":26,"highlight_end":33}],"label":"expected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2308,"byte_end":2313,"line_start":89,"line_end":89,"column_start":20,"column_end":25,"is_primary":false,"text":[{"text":"        self.erc20._mint(account, value)?;","highlight_start":20,"highlight_end":25}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":2236,"byte_end":2320,"line_start":68,"line_end":68,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs","byte_start":1062,"byte_end":2776,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"d8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":77},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":549,"byte_end":578,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":2288,"byte_end":2372,"line_start":69,"line_end":69,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs","byte_start":1090,"byte_end":2806,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":79},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":554,"byte_end":583,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/mod.rs","byte_start":13577,"byte_end":13582,"line_start":420,"line_end":420,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"    pub fn _mint(","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:89:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.erc20._mint(account, value)?;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/mod.rs:420:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m420\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn _mint(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `wrap_fixed_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2502,"byte_end":2504,"line_start":95,"line_end":95,"column_start":29,"column_end":31,"is_primary":true,"text":[{"text":"        self.erc20.transfer(to, value).map_err(|e| e.into())","highlight_start":29,"highlight_end":31}],"label":"expected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2493,"byte_end":2501,"line_start":95,"line_end":95,"column_start":20,"column_end":28,"is_primary":false,"text":[{"text":"        self.erc20.transfer(to, value).map_err(|e| e.into())","highlight_start":20,"highlight_end":28}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":2236,"byte_end":2320,"line_start":68,"line_end":68,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs","byte_start":1062,"byte_end":2776,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"d8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":77},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":549,"byte_end":578,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":2288,"byte_end":2372,"line_start":69,"line_end":69,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs","byte_start":1090,"byte_end":2806,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":79},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":554,"byte_end":583,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/mod.rs","byte_start":6517,"byte_end":6525,"line_start":181,"line_end":181,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"    fn transfer(","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:95:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m95\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.erc20.transfer(to, value).map_err(|e| e.into())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/mod.rs:181:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn transfer(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `wrap_fixed_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this method are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2754,"byte_end":2758,"line_start":105,"line_end":105,"column_start":34,"column_end":38,"is_primary":false,"text":[{"text":"        self.erc20.transfer_from(from, to, value).map_err(|e| e.into())","highlight_start":34,"highlight_end":38}],"label":"expected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2760,"byte_end":2762,"line_start":105,"line_end":105,"column_start":40,"column_end":42,"is_primary":false,"text":[{"text":"        self.erc20.transfer_from(from, to, value).map_err(|e| e.into())","highlight_start":40,"highlight_end":42}],"label":"expected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2740,"byte_end":2753,"line_start":105,"line_end":105,"column_start":20,"column_end":33,"is_primary":true,"text":[{"text":"        self.erc20.transfer_from(from, to, value).map_err(|e| e.into())","highlight_start":20,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":2236,"byte_end":2320,"line_start":68,"line_end":68,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs","byte_start":1062,"byte_end":2776,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"d8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":77},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":549,"byte_end":578,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":2288,"byte_end":2372,"line_start":69,"line_end":69,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs","byte_start":1090,"byte_end":2806,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":79},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":554,"byte_end":583,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":2236,"byte_end":2320,"line_start":68,"line_end":68,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs","byte_start":1062,"byte_end":2776,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"d8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":77},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/macros.rs","byte_start":549,"byte_end":578,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":2288,"byte_end":2372,"line_start":69,"line_end":69,"column_start":9,"column_end":93,"is_primary":true,"text":[{"text":"        $vis struct $name(#[into_iterator(owned, ref, ref_mut)] pub $crate::FixedBytes<$n>);","highlight_start":9,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs","byte_start":1090,"byte_end":2806,"line_start":45,"line_end":87,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"wrap_fixed_bytes!(","highlight_start":1,"highlight_end":19},{"text":"    // we implement Display with the checksum, so we don't derive it","highlight_start":1,"highlight_end":69},{"text":"    extra_derives: [],","highlight_start":1,"highlight_end":23},{"text":"    /// An Ethereum address, 20 bytes in length.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type is separate from [`B160`](crate::B160) / [`FixedBytes<20>`]","highlight_start":1,"highlight_end":78},{"text":"    /// and is declared with the [`wrap_fixed_bytes!`] macro. This allows us","highlight_start":1,"highlight_end":77},{"text":"    /// to implement address-specific functionality.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The main difference with the generic [`FixedBytes`] implementation is that","highlight_start":1,"highlight_end":83},{"text":"    /// [`Display`] formats the address using its [EIP-55] checksum","highlight_start":1,"highlight_end":68},{"text":"    /// ([`to_checksum`]).","highlight_start":1,"highlight_end":27},{"text":"    /// Use [`Debug`] to display the raw bytes without the checksum.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [EIP-55]: https://eips.ethereum.org/EIPS/eip-55","highlight_start":1,"highlight_end":56},{"text":"    /// [`Debug`]: fmt::Debug","highlight_start":1,"highlight_end":30},{"text":"    /// [`Display`]: fmt::Display","highlight_start":1,"highlight_end":34},{"text":"    /// [`to_checksum`]: Address::to_checksum","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Parsing and formatting:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use alloy_primitives::{address, Address};","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let checksummed = \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\";","highlight_start":1,"highlight_end":72},{"text":"    /// let expected = address!(\"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":79},{"text":"    /// let address = Address::parse_checksummed(checksummed, None).expect(\"valid checksum\");","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(address, expected);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address with the checksum","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(address.to_string(), checksummed);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(address.to_checksum(None), checksummed);","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the compressed checksummed address","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!(format!(\"{address:#}\"), \"0xd8dA…6045\");","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Format the address without the checksum","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(format!(\"{address:?}\"), \"0xd8da6bf26964af9d7eed9e03e53415d37aa96045\");","highlight_start":1,"highlight_end":90},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    pub struct Address<20>;","highlight_start":1,"highlight_end":28},{"text":");","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"wrap_fixed_bytes!","def_site_span":{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/macros.rs","byte_start":554,"byte_end":583,"line_start":18,"line_end":18,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"macro_rules! wrap_fixed_bytes {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/mod.rs","byte_start":9445,"byte_end":9458,"line_start":262,"line_end":262,"column_start":8,"column_end":21,"is_primary":true,"text":[{"text":"    fn transfer_from(","highlight_start":8,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: arguments to this method are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:105:20\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.erc20.transfer_from(from, to, value).map_err(|e| e.into())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `alloy::alloy_primitives::Address`, found `alloy_primitives::Address`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` and `alloy::alloy_primitives::Address` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy::alloy_primitives::Address` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/address.rs:45:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mwrap_fixed_bytes!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    // we implement Display with the checksum, so we don't derive it\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    extra_derives: [],\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An Ethereum address, 20 bytes in length.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Address<20>;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/token/erc20/mod.rs:262:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn transfer_from(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `wrap_fixed_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2899,"byte_end":2911,"line_start":109,"line_end":109,"column_start":35,"column_end":47,"is_primary":true,"text":[{"text":"        Erc20::supports_interface(interface_id)","highlight_start":35,"highlight_end":47}],"label":"expected `FixedBytes<4>`, found `alloy_primitives::FixedBytes<4>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2873,"byte_end":2898,"line_start":109,"line_end":109,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"        Erc20::supports_interface(interface_id)","highlight_start":9,"highlight_end":34}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`alloy_primitives::FixedBytes<4>` and `FixedBytes<4>` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::FixedBytes<4>` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/fixed.rs","byte_start":857,"byte_end":894,"line_start":34,"line_end":34,"column_start":1,"column_end":38,"is_primary":true,"text":[{"text":"pub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);","highlight_start":1,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`FixedBytes<4>` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/fixed.rs","byte_start":939,"byte_end":976,"line_start":33,"line_end":33,"column_start":1,"column_end":38,"is_primary":true,"text":[{"text":"pub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);","highlight_start":1,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/utils/introspection/erc165.rs","byte_start":1391,"byte_end":1409,"line_start":42,"line_end":42,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    fn supports_interface(interface_id: FixedBytes<4>) -> bool;","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:109:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Erc20::supports_interface(interface_id)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `FixedBytes<4>`, found `alloy_primitives::FixedBytes<4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::FixedBytes<4>` and `FixedBytes<4>` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::FixedBytes<4>` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/fixed.rs:34:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `FixedBytes<4>` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/fixed.rs:33:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/utils/introspection/erc165.rs:42:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn supports_interface(interface_id: FixedBytes<4>) -> bool;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":2962,"byte_end":2974,"line_start":110,"line_end":110,"column_start":50,"column_end":62,"is_primary":true,"text":[{"text":"            || Erc20Metadata::supports_interface(interface_id)","highlight_start":50,"highlight_end":62}],"label":"expected `FixedBytes<4>`, found `alloy_primitives::FixedBytes<4>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":2928,"byte_end":2961,"line_start":110,"line_end":110,"column_start":16,"column_end":49,"is_primary":false,"text":[{"text":"            || Erc20Metadata::supports_interface(interface_id)","highlight_start":16,"highlight_end":49}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`alloy_primitives::FixedBytes<4>` and `FixedBytes<4>` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`alloy_primitives::FixedBytes<4>` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/fixed.rs","byte_start":857,"byte_end":894,"line_start":34,"line_end":34,"column_start":1,"column_end":38,"is_primary":true,"text":[{"text":"pub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);","highlight_start":1,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`FixedBytes<4>` is defined in crate `alloy_primitives`","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/fixed.rs","byte_start":939,"byte_end":976,"line_start":33,"line_end":33,"column_start":1,"column_end":38,"is_primary":true,"text":[{"text":"pub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);","highlight_start":1,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `alloy_primitives` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/utils/introspection/erc165.rs","byte_start":1391,"byte_end":1409,"line_start":42,"line_end":42,"column_start":8,"column_end":26,"is_primary":true,"text":[{"text":"    fn supports_interface(interface_id: FixedBytes<4>) -> bool;","highlight_start":8,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib.rs:110:50\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m110\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            || Erc20Metadata::supports_interface(interface_id)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `FixedBytes<4>`, found `alloy_primitives::FixedBytes<4>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `alloy_primitives::FixedBytes<4>` and `FixedBytes<4>` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `alloy_primitives::FixedBytes<4>` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.3.3/src/bits/fixed.rs:34:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `FixedBytes<4>` is defined in crate `alloy_primitives`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/registry/src/index.crates.io-6f17d22bba15001f/alloy-primitives-0.8.20/src/bits/fixed.rs:33:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct FixedBytes<const N: usize>(#[into_iterator(owned, ref, ref_mut)] pub [u8; N]);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `alloy_primitives` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/jeonghyeongseob/.cargo/git/checkouts/rust-contracts-stylus-7b6f4dfe793ef8eb/20ffabe/contracts/src/utils/introspection/erc165.rs:42:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn supports_interface(interface_id: FixedBytes<4>) -> bool;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 18 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 18 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0308.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
